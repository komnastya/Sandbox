import dis


# LAMBDA

def identity(x):
    return x


# In contrast, if you use a Python lambda construction, you get the following:
assert (lambda x: x)(1) == 1

# You can write a slightly more elaborated example, a function that adds 1 to an argument, as follows:
assert (lambda x: x + 1)(1) == 2

# Because a lambda function is an expression, it can be named. Therefore you could write the previous code as follows:
add_one = lambda x: x + 1
assert add_one(2) == 3


# The above lambda function is equivalent to writing this:
def add_one2(x):
    return x + 1


# These functions all take a single argument. You may have noticed that, in the definition of the lambdas, the arguments
# don’t have parentheses around them. Multi-argument functions (functions that take more than one argument) are
# expressed in Python lambdas by listing arguments and separating them with a comma (,) but without surrounding them
# with parentheses:

full_name = lambda first, last: f'Full name: {first.title()} {last.title()}'

# As expected, the definition of the lambda lists the arguments with no parentheses, whereas calling the function
# is done exactly like a normal Python function, with parentheses surrounding the arguments.
assert full_name('nastassia', 'kamiakova') == 'Full name: Nastassia Kamiakova'

# ANONYMOUS FUNCTIONS

# Python does not encourage using immediately invoked lambda expressions. It simply results from a lambda expression
# being callable, unlike the bo#dy of a normal function.

# Lambda functions are frequently used with higher-order functions, which take one or more functions as arguments or
# return one or more functions.

# A lambda function can be a higher-order function by taking a function (normal or lambda) as an argument like in
# the following contrived example:
high_ord_func = lambda x, func: x + func(x)
assert high_ord_func(2, lambda x: x * x) == 6
assert high_ord_func(2, lambda x: x + 3) == 7

# PYTHON LAMBDA AND REGULAR FUNCTIONS
# FUNCTIONS

# At this point, you may wonder what fundamentally distinguishes a lambda function bound to a variable from a regular
# function with a single return line: under the surface, almost nothing.
# Let’s verify how Python sees a function built with a single return statement versus a function constructed as an
# expression (lambda).

# The dis module exposes functions to analyze Python bytecode generated by the Python compiler:
add = lambda x, y: x + y
print(type(add))
print(dis.dis(add))
print(add)


# You can see that dis() expose a readable version of the Python bytecode allowing the inspection of the low-level
# instructions that the Python interpreter will use while executing the program.
# Now see it with a regular function object:

def add_two(x, y):
    return x + y


print(type(add_two))
print(dis.dis(add_two))
print(add_two)

# The bytecode interpreted by Python is the same for both functions. But you may notice that the naming is different:
# the function name is 'add_two' for a function defined with def, whereas the Python lambda function is seen as
# 'lambda'.

# TRACEBACK

# You saw in the previous section that, in the context of the lambda function, Python did not provide the name of the
# function, but only <lambda>. This can be a limitation to consider when an exception occurs, and a traceback shows
# only <lambda>:

div_zero = lambda x: x / 0
# div_zero(2)

# SYNTAX

# A lambda function can’t contain any statements. In a lambda function, statements like return, pass, assert, or raise
# will raise a SyntaxError exception. Here’s an example of adding assert to the body of a lambda:
# >>> (lambda x: assert x == 2)(2) -> SyntaxError

# Single Expression
# In contrast to a normal function, a Python lambda function is a single expression. Although, in the body of a lambda,
# you can spread the expression over several lines using parentheses or a multiline string, it remains a single
# expression:

odd_or_even = (lambda x:
               (x % 2 and 'odd' or 'even'))
assert odd_or_even(3) == 'odd'
assert odd_or_even(4) == 'even'


# The example above returns the string 'odd' when the lambda argument is odd, and 'even' when the argument is even.
# It spreads across two lines because it is contained in a set of parentheses, but it remains a single expression.

# TYPE ANNOTATION

# If you’ve started adopting type hinting, which is now available in Python, then you have another good reason to
# prefer normal functions over Python lambda functions. In a lambda function, there is no equivalent for the following:

def full_name(first: str, last: str) -> str:
    return f'{first.title()} {last.title()}'


# Any type error with full_name() can be caught by tools like mypy or pyre, whereas a SyntaxError with the equivalent
# lambda function is raised at runtime:
# lambda first: str, last: str: first.title() + " " + last.title() -> str >>> SyntaxError: invalid syntax

# IIFE ("iffy")
# You’ve already seen several examples of immediately invoked function execution:
assert (lambda x: x * x)(3) == 9
# Outside of the Python interpreter, this feature is probably not used in practice. It’s a direct consequence of a
# lambda function being callable as it is defined. For example, this allows you to pass the definition of a Python
# lambda expression to a higher-order function like map(), filter(), or functools.reduce(), or to a key function.

# ARGUMENTS
# Like a normal function object defined with def, Python lambda expressions support all the different ways of
# passing arguments. Examples:
assert (lambda x, y, z: x + y + z)(1, 2, 3) == 6
assert (lambda x, y, z=3: x + y + z)(1, 2) == 6
assert (lambda x, y, z=3: x + y + z)(1, y=2) == 6
assert (lambda *args: sum(args))(1, 2, 3) == 6
assert (lambda **kwargs: sum(kwargs.values()))(one=1, two=2, three=3) == 6
assert (lambda x, *, y=0, z=0: x + y + z)(1, y=2, z=3) == 6


# DECORATORS
# In Python, a decorator is the implementation of a pattern that allows adding a behavior to a function or a class.
# It is usually expressed with the @decorator syntax prefixing a function. Here’s a contrived example:

def some_decorator(f):
    def wraps(*args):
        print(f"Calling function '{f.__name__}'")
        return f(*args)

    return wraps


@some_decorator
def decorated_function(x):
    print(f"With argument '{x}'")


# In the example above, some_decorator() is a function that adds a behavior to decorated_function(), so that
# invoking decorated_function("Python") results in the following output:

decorated_function("Python")


# decorated_function() only prints "With argument 'Python'", but the decorator adds an extra behavior that also
# prints "Calling function 'decorated_function'".

# A decorator can be applied to a lambda. Although it’s not possible to decorate a lambda with the @decorator syntax,
# a decorator is just a function, so it can call the lambda function:

# Defining a decorator
def trace(f):
    def wrap(*args, **kwargs):
        print(f"[TRACE] func: {f.__name__}, args: {args}, kwargs: {kwargs}")
        return f(*args, **kwargs)

    return wrap


# Applying decorator to a function
@trace
def add_three(x):
    return x + 3


# Calling the decorated function
print(add_three(3))

# Applying decorator to a lambda
print((trace(lambda x: x ** 2))(3))

# Decorating the lambda function this way could be useful for debugging purposes, possibly to debug the behavior of
# a lambda function used in the context of a higher-order function or a key function. Let’s see an example with map():
print(list(map(trace(lambda x: x * 2), range(3))))


# CLOSURE
# A closure is a function where every free variable, everything except parameters, used in that function is bound
# to a specific value defined in the enclosing scope of that function. In effect, closures define the environment in
# which they run, and so can be called from anywhere.

# Here’s a closure constructed with a normal Python function:

def outer_func(x):
    y = 4

    def inner_func(z):
        print(f"x = {x}, y = {y}, z = {z}")
        return x + y + z

    return inner_func


for i in range(3):
    closure = outer_func(i)
    print(f"closure({i + 5}) = {closure(i + 5)}")

print(outer_func(3))

# On line 207 of the code, inner_func() returned by the invocation of outer_func() is bound to the name 'closure'.
# On line 203, inner_func() captures x and y because it has access to its embedding environment, such that upon
# invocation of the closure, it is able to operate on the two free variables x and y.

a = outer_func(5)
print(a(5))  # 5 + 4 + 5 = 14


# Similarly, a lambda can also be a closure. Here’s the same example with a Python lambda function:
def outer_func2(x):
    y = 4
    return lambda z: x + y + z


for i in range(3):
    closure = outer_func2(i)
    print(f"closure({i + 5}) = {closure(i + 5)}")


# EVALUATION TIME
# In some situations involving loops, the behavior of a Python lambda function as a closure may be counterintuitive.
# It requires understanding when free variables are bound in the context of a lambda. The following examples
# demonstrate the difference when using a regular function vs using a Python lambda.
# Test the scenario first using a regular function:

print('Using a regular function')
def wrap(n):
    def f():
        print(n)
    return f

numbers = ['one', 'two', 'three']
funcs = []
for n in numbers:
    funcs.append(wrap(n))

for f in funcs:
    f()

# In a normal function, n is evaluated at definition time, on line 253, when the function is added to the list:
# funcs.append(wrap(n)).

# Now, with the implementation of the same logic with a lambda function, observe the unexpected behavior:

print('Have unexpected result using a lambda ')
funcs = []
for n in numbers:
    funcs.append(lambda: print(n))

for f in funcs:
    f()

# The unexpected result occurs because the free variable n, as implemented, is bound at the execution time of the
# lambda expression. The Python lambda function on line 4 is a closure that captures n, a free variable bound at
# runtime. At runtime, while invoking the function f on line 7, the value of n is three.
# To overcome this issue, you can assign the free variable at definition time as follows:
print('Using a lambda rightly')
funcs = []
for n in numbers:
    funcs.append(lambda x=n: print(x))

for f in funcs:
    f()
