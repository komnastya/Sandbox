import dis
import functools
from functools import reduce


# LAMBDA

def identity(x):
    return x


# In contrast, if you use a Python lambda construction, you get the following:
assert (lambda x: x)(1) == 1

# You can write a slightly more elaborated example, a function that adds 1 to an argument, as follows:
assert (lambda x: x + 1)(1) == 2

# Because a lambda function is an expression, it can be named. Therefore you could write the previous code as follows:
add_one = lambda x: x + 1
assert add_one(2) == 3


# The above lambda function is equivalent to writing this:
def add_one2(x):
    return x + 1


# These functions all take a single argument. You may have noticed that, in the definition of the lambdas, the arguments
# don’t have parentheses around them. Multi-argument functions (functions that take more than one argument) are
# expressed in Python lambdas by listing arguments and separating them with a comma (,) but without surrounding them
# with parentheses:

full_name = lambda first, last: f'Full name: {first.title()} {last.title()}'

# As expected, the definition of the lambda lists the arguments with no parentheses, whereas calling the function
# is done exactly like a normal Python function, with parentheses surrounding the arguments.
assert full_name('nastassia', 'kamiakova') == 'Full name: Nastassia Kamiakova'

# ANONYMOUS FUNCTIONS

# Python does not encourage using immediately invoked lambda expressions. It simply results from a lambda expression
# being callable, unlike the bo#dy of a normal function.

# Lambda functions are frequently used with higher-order functions, which take one or more functions as arguments or
# return one or more functions.

# A lambda function can be a higher-order function by taking a function (normal or lambda) as an argument like in
# the following contrived example:
high_ord_func = lambda x, func: x + func(x)
assert high_ord_func(2, lambda x: x * x) == 6
assert high_ord_func(2, lambda x: x + 3) == 7

# PYTHON LAMBDA AND REGULAR FUNCTIONS
# FUNCTIONS

# At this point, you may wonder what fundamentally distinguishes a lambda function bound to a variable from a regular
# function with a single return line: under the surface, almost nothing.
# Let’s verify how Python sees a function built with a single return statement versus a function constructed as an
# expression (lambda).

# The dis module exposes functions to analyze Python bytecode generated by the Python compiler:
add = lambda x, y: x + y
print(type(add))
print(dis.dis(add))
print(add)


# You can see that dis() expose a readable version of the Python bytecode allowing the inspection of the low-level
# instructions that the Python interpreter will use while executing the program.
# Now see it with a regular function object:

def add_two(x, y):
    return x + y


print(type(add_two))
print(dis.dis(add_two))
print(add_two)

# The bytecode interpreted by Python is the same for both functions. But you may notice that the naming is different:
# the function name is 'add_two' for a function defined with def, whereas the Python lambda function is seen as
# 'lambda'.

# TRACEBACK

# You saw in the previous section that, in the context of the lambda function, Python did not provide the name of the
# function, but only <lambda>. This can be a limitation to consider when an exception occurs, and a traceback shows
# only <lambda>:

div_zero = lambda x: x / 0
# div_zero(2)

# SYNTAX

# A lambda function can’t contain any statements. In a lambda function, statements like return, pass, assert, or raise
# will raise a SyntaxError exception. Here’s an example of adding assert to the body of a lambda:
# >>> (lambda x: assert x == 2)(2) -> SyntaxError

# Single Expression
# In contrast to a normal function, a Python lambda function is a single expression. Although, in the body of a lambda,
# you can spread the expression over several lines using parentheses or a multiline string, it remains a single
# expression:

odd_or_even = (lambda x:
               (x % 2 and 'odd' or 'even'))
assert odd_or_even(3) == 'odd'
assert odd_or_even(4) == 'even'


# The example above returns the string 'odd' when the lambda argument is odd, and 'even' when the argument is even.
# It spreads across two lines because it is contained in a set of parentheses, but it remains a single expression.

# TYPE ANNOTATION

# If you’ve started adopting type hinting, which is now available in Python, then you have another good reason to
# prefer normal functions over Python lambda functions. In a lambda function, there is no equivalent for the following:

def full_name(first: str, last: str) -> str:
    return f'{first.title()} {last.title()}'


# Any type error with full_name() can be caught by tools like mypy or pyre, whereas a SyntaxError with the equivalent
# lambda function is raised at runtime:
# lambda first: str, last: str: first.title() + " " + last.title() -> str >>> SyntaxError: invalid syntax

# IIFE ("iffy")
# You’ve already seen several examples of immediately invoked function execution:
assert (lambda x: x * x)(3) == 9
# Outside of the Python interpreter, this feature is probably not used in practice. It’s a direct consequence of a
# lambda function being callable as it is defined. For example, this allows you to pass the definition of a Python
# lambda expression to a higher-order function like map(), filter(), or functools.reduce(), or to a key function.

# ARGUMENTS
# Like a normal function object defined with def, Python lambda expressions support all the different ways of
# passing arguments. Examples:
assert (lambda x, y, z: x + y + z)(1, 2, 3) == 6
assert (lambda x, y, z=3: x + y + z)(1, 2) == 6
assert (lambda x, y, z=3: x + y + z)(1, y=2) == 6
assert (lambda *args: sum(args))(1, 2, 3) == 6
assert (lambda **kwargs: sum(kwargs.values()))(one=1, two=2, three=3) == 6
assert (lambda x, *, y=0, z=0: x + y + z)(1, y=2, z=3) == 6


# DECORATORS
# In Python, a decorator is the implementation of a pattern that allows adding a behavior to a function or a class.
# It is usually expressed with the @decorator syntax prefixing a function. Here’s a contrived example:

def some_decorator(f):
    def wraps(*args):
        print(f"Calling function '{f.__name__}'")
        return f(*args)

    return wraps


@some_decorator
def decorated_function(x):
    print(f"With argument '{x}'")


# In the example above, some_decorator() is a function that adds a behavior to decorated_function(), so that
# invoking decorated_function("Python") results in the following output:

decorated_function("Python")


# decorated_function() only prints "With argument 'Python'", but the decorator adds an extra behavior that also
# prints "Calling function 'decorated_function'".

# A decorator can be applied to a lambda. Although it’s not possible to decorate a lambda with the @decorator syntax,
# a decorator is just a function, so it can call the lambda function:

# Defining a decorator
def trace(f):
    def wrap(*args, **kwargs):
        print(f"[TRACE] func: {f.__name__}, args: {args}, kwargs: {kwargs}")
        return f(*args, **kwargs)

    return wrap


# Applying decorator to a function
@trace
def add_three(x):
    return x + 3


# Calling the decorated function
print(add_three(3))

# Applying decorator to a lambda
print((trace(lambda x: x ** 2))(3))

# Decorating the lambda function this way could be useful for debugging purposes, possibly to debug the behavior of
# a lambda function used in the context of a higher-order function or a key function. Let’s see an example with map():
print(list(map(trace(lambda x: x * 2), range(3))))


# CLOSURE
# A closure is a function where every free variable, everything except parameters, used in that function is bound
# to a specific value defined in the enclosing scope of that function. In effect, closures define the environment in
# which they run, and so can be called from anywhere.

# Here’s a closure constructed with a normal Python function:

def outer_func(x):
    y = 4

    def inner_func(z):
        print(f"x = {x}, y = {y}, z = {z}")
        return x + y + z

    return inner_func


for i in range(3):
    closure = outer_func(i)
    print(f"closure({i + 5}) = {closure(i + 5)}")

print(outer_func(3))

# On line 207 of the code, inner_func() returned by the invocation of outer_func() is bound to the name 'closure'.
# On line 203, inner_func() captures x and y because it has access to its embedding environment, such that upon
# invocation of the closure, it is able to operate on the two free variables x and y.

a = outer_func(5)
print(a(5))  # 5 + 4 + 5 = 14


# Similarly, a lambda can also be a closure. Here’s the same example with a Python lambda function:
def outer_func2(x):
    y = 4
    return lambda z: x + y + z


for i in range(3):
    closure = outer_func2(i)
    print(f"closure({i + 5}) = {closure(i + 5)}")

# EVALUATION TIME
# In some situations involving loops, the behavior of a Python lambda function as a closure may be counterintuitive.
# It requires understanding when free variables are bound in the context of a lambda. The following examples
# demonstrate the difference when using a regular function vs using a Python lambda.
# Test the scenario first using a regular function:

print('Using a regular function')


def wrap(n):
    def f():
        print(n)

    return f


numbers = ['one', 'two', 'three']
funcs = []
for n in numbers:
    funcs.append(wrap(n))

for f in funcs:
    f()

# In a normal function, n is evaluated at definition time, on line 253, when the function is added to the list:
# funcs.append(wrap(n)).

# Now, with the implementation of the same logic with a lambda function, observe the unexpected behavior:

print('Have unexpected result using a lambda ')
funcs = []
for n in numbers:
    funcs.append(lambda: print(n))

for f in funcs:
    f()

# The unexpected result occurs because the free variable n, as implemented, is bound at the execution time of the
# lambda expression. The Python lambda function on line 4 is a closure that captures n, a free variable bound at
# runtime. At runtime, while invoking the function f on line 7, the value of n is three.
# To overcome this issue, you can assign the free variable at definition time as follows:
print('Using a lambda rightly')
funcs = []
for n in numbers:
    funcs.append(lambda x=n: print(x))

for f in funcs:
    f()


# LAMBDA EXPRESSION ABUSES

# The next sections illustrate a few examples of lambda usages that should be avoided. Those examples might be
# situations where, in the context of Python lambda, the code exhibits the following pattern:

# It doesn’t follow the Python style guide (PEP 8)
# It’s cumbersome and difficult to read.
# It’s unnecessarily clever at the cost of difficult readability.

# RAISING AN EXCEPTION
# Trying to raise an exception in a Python lambda should make you think twice. There are some clever ways to
# do so, but even something like the following is better to avoid:

def throw(ex):
    raise ex


a = lambda: throw(Exception('Something bad happened'))()

# a() -> Exception: Something bad happened

# Because a statement is not syntactically correct in a Python lambda body, the workaround in the example above
# consists of abstracting the statement call with a dedicated function throw(). Using this type of workaround
# should be avoided. If you encounter this type of code, you should consider refactoring the code to use a regular
# function.

# CRYPTIC STYLE

# As in any programming languages, you will find Python code that can be difficult to read because of the style used.
# Lambda functions, due to their conciseness, can be conducive to writing code that is difficult to read.

# The following lambda example contains several bad style choices:

assert (lambda _: list(map(lambda _: _ // 2, _)))([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [0, 1, 1, 2, 2, 3, 3, 4, 4, 5]

# The underscore (_) refers to a variable that you don’t need to refer to explicitly. But in this example,
# three _ refer to different variables. An initial upgrade to this lambda code could be to name the variables:

assert (lambda some_list: list(map(lambda n: n // 2, some_list)))([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [0, 1, 1, 2, 2, 3,
                                                                                                       3, 4, 4, 5]


# Admittedly, it’s still difficult to read. By still taking advantage of a lambda, a regular function would go a
# long way to render this code more readable, spreading the logic over a few lines and function calls:

def div_items(some_list):
    div_by_two = lambda n: n // 2
    return map(div_by_two, some_list)


assert list(div_items([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])) == [0, 1, 1, 2, 2, 3, 3, 4, 4, 5]


# This is still not optimal but shows you a possible path to make code, and Python lambda functions in particular,
# more readable.

# my experiment

def div_items_without_lambda(some_list):
    def div(n):
        return n // 2

    return map(div, some_list)


assert list(div_items_without_lambda([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])) == [0, 1, 1, 2, 2, 3, 3, 4, 4, 5]


# PYTHON CLASSES
# You can but should not write class methods as Python lambda functions. The following example is perfectly legal
# Python code but exhibits unconventional Python code relying on lambda. For example, instead of implementing
# __str__ as a regular function, it uses a lambda. Similarly, brand and year are properties also implemented with
# lambda functions, instead of regular functions or decorators:

class Car:
    """Car with methods as lambda functions."""

    def __init__(self, brand, year):
        self.brand = brand
        self.year = year

    brand = property(lambda self: getattr(self, '_brand'),
                     lambda self, value: setattr(self, '_brand', value))
    # proper implementation:
    # @property
    # def brand(self):
    #     return self._brand
    #
    # @brand.setter
    # def brand(self, value):
    #     self._brand = value

    year = property(lambda self: getattr(self, '_year'),
                    lambda self, value: setattr(self, '_year', value))

    __str__ = lambda self: f'{self.brand} {self.year}'  # 1: error E731
    # proper implementation:
    # def __str__(self):
    #     return f'{self.brand} {self.year}'

    honk = lambda self: print('Honk!')  # 2: error E731


# Running a tool like flake8, a style guide enforcement tool, will display the following errors for __str__ and honk:
# E731 do not assign a lambda expression, use a def

# As a general rule, in the context of code written in Python, prefer regular functions over lambda expressions.

# APPROPRIATE USING OF LAMBDA EXPRESSION

# Lambdas in Python tend to be the subject of controversies. The following examples illustrate scenarios where the
# use of lambda functions is not only suitable but encouraged in Python code.

# CLASSIC FUNCTIONAL CONSTRUCTS

# Lambda functions are regularly used with the built-in functions map() and filter(), as well as functools.reduce(),
# exposed in the module functools. The following three examples are respective illustrations of using those functions
# with lambda expressions as companions:

assert list(map(lambda x: x.upper(), ['cat', 'dog', 'cow'])) == ['CAT', 'DOG', 'COW']
assert list(filter(lambda x: 'o' in x, ['cat', 'dog', 'cow'])) == ['dog', 'cow']

assert reduce(lambda acc, x: f'{acc} | {x}', ['cat', 'dog', 'cow']) == 'cat | dog | cow'

# KEY FUNCTIONS
# Key functions in Python are higher-order functions that take a parameter key as a named argument. key receives a
# function that can be a lambda. This function directly influences the algorithm driven by the key function itself.
# Here are some key functions:

# sort(): list method
# sorted(), min(), max(): built-in functions
# nlargest() and nsmallest(): in the Heap queue algorithm module heapq

# Imagine that you want to sort a list of IDs represented as strings. Each ID is the concatenation of the string id and
# a number. Sorting this list with the built-in function sorted(), by default, uses a lexicographic order as the
# elements in the list are strings.

# To influence the sorting execution, you can assign a lambda to the named argument key, such that the sorting will
# use the number associated with the ID:

ids = ['id1', 'id2', 'id30', 'id3', 'id22', 'id100']
assert (sorted(ids)) == ['id1', 'id100', 'id2', 'id22', 'id3', 'id30']  # Lexicographic sort

sorted_ids = sorted(ids, key=lambda x: int(x[2:]))  # Integer sort
assert sorted_ids == ['id1', 'id2', 'id3', 'id22', 'id30', 'id100']

# PYTHON INTERPRETER

# It’s easy to craft a quick one-liner function to explore some snippets of code that will never see the light of day
# outside of the interpreter. The lambdas written in the interpreter, for the sake of speedy discovery, are like scrap
# paper that you can throw away after use.

# timeit

# In the same spirit as the experimentation in the Python interpreter, the module timeit provides functions to time
# small code fragments. timeit.timeit() in particular can be called directly, passing some Python code in a string.
# Here’s an example:

from timeit import timeit

print('Execution time of string version', timeit("factorial(999)", "from math import factorial", number=10))

# When the statement is passed as a string, timeit() needs the full context. In the example above, this is provided
# by the second argument that sets up the environment needed by the main function to be timed. Not doing so would
# raise a NameError exception.

# Another approach is to use a lambda:
from math import factorial

print('Execution time of lambda version', timeit(lambda: factorial(999), number=10))

# This solution is cleaner, more readable, and quicker to type in the interpreter. Although the execution time was
# slightly less for the lambda version, executing the functions again may show a slight advantage for the string
# version. The execution time of the setup is excluded from the overall execution time and shouldn’t have any impact
# on the result.

# ALTERNATIVES TO USING LAMBDA

# Higher-order functions like map(), filter(), and functools.reduce() can be converted to more elegant forms with
# slight twists of creativity, in particular with list comprehensions or generator expressions.

# MAP

# The built-in function map() takes a function as a first argument and applies it to each of the elements of its
# second argument, an iterable (which are strings, lists, or tuples).

# map() returns an iterator corresponding to the transformed collection. As an example, if you wanted to transform a
# list of strings to a new list with each string capitalized, you could use map(), as follows:

assert list(map(lambda x: x.capitalize(), ['cat', 'dog', 'cow'])) == ['Cat', 'Dog', 'Cow']

# Using a list comprehension eliminates the need for defining and invoking the lambda function:

assert [x.capitalize() for x in ['cat', 'dog', 'cow']] == ['Cat', 'Dog', 'Cow']

# FILTER

# The built-in function filter(), another classic functional construct, can be converted into a list comprehension.
# It takes a predicate as a first argument and an iterable as a second argument. It builds an iterator containing all
# the elements of the initial collection that satisfies the predicate function. Here’s an example that filters all
# the even numbers in a given list of integers:

even = lambda x: x % 2 == 0
assert list(filter(even, range(11))) == [0, 2, 4, 6, 8, 10]
assert list(filter(lambda x: x % 2 == 1, range(11))) == [1, 3, 5, 7, 9]  # odd

# Note that filter() returns an iterator, hence the need to invoke the built-in type list that constructs a list
# given an iterator.

# The implementation leveraging the list comprehension construct gives the following:
assert [x for x in range(11) if x % 2 == 0] == [0, 2, 4, 6, 8, 10]

# REDUCE

# Since Python 3, reduce() has gone from a built-in function to a functools module function. As map() and filter(),
# its first two arguments are respectively a function and an iterable. It may also take an initializer as a third
# argument that is used as the initial value of the resulting accumulator. For each element of the iterable,
# reduce() applies the function and accumulates the result that is returned when the iterable is exhausted.

# To apply reduce() to a list of pairs and calculate the sum of the first item of each pair, you could write this:
pairs = [(1, 'a'), (2, 'b'), (3, 'c')]
assert functools.reduce(lambda acc, pair: acc + pair[0], pairs, 0) == 6

# A more idiomatic approach using a generator expression, as an argument to sum() in the example, is the following:

pairs = [(1, 'a'), (2, 'b'), (3, 'c')]
assert sum(x[0] for x in pairs) == 6

# A slightly different and possibly cleaner solution removes the need to explicitly access the first element of the
# pair and instead use unpacking:

pairs = [(1, 'a'), (2, 'b'), (3, 'c')]
assert sum(x for x, _ in pairs) == 6
# The use of underscore (_) is a Python convention indicating that you can ignore the second value of the pair.
# sum() takes a unique argument, so the generator expression does not need to be in parentheses.
